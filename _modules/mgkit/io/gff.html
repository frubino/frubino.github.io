

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>mgkit.io.gff &mdash; MGKit: Metagenomic framework 0.5.3 documentation</title>
  

  
  <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../../_static/graphviz.css" type="text/css" />

  
  
  
  

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../../" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/language_data.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../../index.html" class="icon icon-home" alt="Documentation Home"> MGKit: Metagenomic framework
          

          
          </a>

          
            
            
              <div class="version">
                0.5.3
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../pipeline/index.html">Metagenomic Pipeline</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Scripts Details</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Example Notebooks</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gff.html">MGKit GFF Specifications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../library.html">Library Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changes.html">Changes</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MGKit: Metagenomic framework</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="../../index.html">Module code</a> &raquo;</li>
        
          <li><a href="../../mgkit.html">mgkit</a> &raquo;</li>
        
      <li>mgkit.io.gff</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for mgkit.io.gff</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This modules define classes and function related to manipulation of GFF/GTF</span>
<span class="sd">files.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="nb">object</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">range</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">IOBase</span>
<span class="kn">from</span> <span class="nn">future.utils</span> <span class="kn">import</span> <span class="n">viewitems</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">uuid</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">urllib</span> <span class="kn">import</span> <span class="n">unquote</span><span class="p">,</span> <span class="n">quote</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="c1"># Python3</span>
    <span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">unquote</span><span class="p">,</span> <span class="n">quote</span>
<span class="kn">import</span> <span class="nn">mgkit.io</span>
<span class="kn">from</span> <span class="nn">..utils</span> <span class="kn">import</span> <span class="n">sequence</span> <span class="k">as</span> <span class="n">seq_utils</span>
<span class="kn">from</span> <span class="nn">..consts</span> <span class="kn">import</span> <span class="n">MIN_COV</span>
<span class="kn">from</span> <span class="nn">..utils.common</span> <span class="kn">import</span> <span class="n">between</span><span class="p">,</span> <span class="n">union_range</span><span class="p">,</span> <span class="n">ranges_length</span>
<span class="kn">from</span> <span class="nn">..utils.trans_tables</span> <span class="kn">import</span> <span class="n">UNIVERSAL</span>

<span class="n">LOG</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<div class="viewcode-block" id="AttributeNotFound"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.AttributeNotFound">[docs]</a><span class="k">class</span> <span class="nc">AttributeNotFound</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Raised if an attribute is not found in a GFF file</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="write_gff"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.write_gff">[docs]</a><span class="k">def</span> <span class="nf">write_gff</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionchanged:: 0.1.12</span>
<span class="sd">        added *verbose* argument</span>

<span class="sd">    Write a GFF to file</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): iterable that returns :class:`GFFKegg`</span>
<span class="sd">            or :class:`Annotation` instances</span>
<span class="sd">        file_handle (str, file): file name or file handle to write to</span>
<span class="sd">        verbose (bool): if True, a message is logged</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">file_handle</span> <span class="o">=</span> <span class="n">mgkit</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Writing annotations to file (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">file_handle</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)</span></div>


<div class="viewcode-block" id="GenomicRange"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.GenomicRange">[docs]</a><span class="k">class</span> <span class="nc">GenomicRange</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a genomic range</span>

<span class="sd">    .. versionchanged:: 0.2.1</span>
<span class="sd">        using __slots__ for better memory usage</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">)</span>

    <span class="c1"># seq_id = &#39;None&#39;</span>
    <span class="c1"># &quot;Sequence ID&quot;</span>
    <span class="c1"># strand = &#39;+&#39;</span>
    <span class="c1"># &quot;Strand&quot;</span>
    <span class="c1"># start = None</span>
    <span class="c1"># &quot;Start of the range, 1-based&quot;</span>
    <span class="c1"># end = None</span>
    <span class="c1"># &quot;End of the range 1-based&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_id</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">strand</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_id</span> <span class="o">=</span> <span class="n">seq_id</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="n">strand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_id</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">seq_id</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">strand</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">(</span><span class="si">{1}</span><span class="s2">):</span><span class="si">{2}</span><span class="s2">-</span><span class="si">{3}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">strand</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">end</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="GenomicRange.union"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.GenomicRange.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the union of two :class:`GenomicRange`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">seq_id</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">strand</span><span class="p">):</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">union_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">result</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>

                <span class="n">gen_range</span> <span class="o">=</span> <span class="n">GenomicRange</span><span class="p">()</span>
                <span class="n">gen_range</span><span class="o">.</span><span class="n">seq_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_id</span>
                <span class="n">gen_range</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span>
                <span class="n">gen_range</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">gen_range</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="k">return</span> <span class="n">gen_range</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="fm">__or__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="GenomicRange.expand_from_list"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.GenomicRange.expand_from_list">[docs]</a>    <span class="k">def</span> <span class="nf">expand_from_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">others</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Expand the :class:`GenomicRange` range instance with a list of</span>
<span class="sd">        :class:`GenomicRange`</span>

<span class="sd">        Arguments:</span>
<span class="sd">            others (iterable): iterable of :class:`GenomicRange`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_range</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">for</span> <span class="n">other</span> <span class="ow">in</span> <span class="n">others</span><span class="p">:</span>
            <span class="n">union</span> <span class="o">=</span> <span class="n">new_range</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">union</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">new_range</span> <span class="o">=</span> <span class="n">union</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">new_range</span><span class="o">.</span><span class="n">start</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">new_range</span><span class="o">.</span><span class="n">end</span></div>

<div class="viewcode-block" id="GenomicRange.intersect"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.GenomicRange.intersect">[docs]</a>    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return an instance of :class:`GenomicRange` that represent the</span>
<span class="sd">        intersection of the current instance and another.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_id</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">seq_id</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">strand</span><span class="p">):</span>

            <span class="k">if</span> <span class="n">between</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="n">between</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="n">between</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">)</span> <span class="ow">or</span> \
               <span class="n">between</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">):</span>

                <span class="n">gen_range</span> <span class="o">=</span> <span class="n">GenomicRange</span><span class="p">()</span>
                <span class="n">gen_range</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
                <span class="n">gen_range</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">gen_range</span>

        <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="fm">__and__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="GenomicRange.__contains__"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.GenomicRange.__contains__">[docs]</a>    <span class="k">def</span> <span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        .. versionchanged:: 0.2.3</span>
<span class="sd">            a range or a subclass are accepted</span>

<span class="sd">        .. versionadded:: 0.1.16</span>

<span class="sd">        Tests if the position is inside the range of the GenomicRange</span>

<span class="sd">        Pos is 1-based as :attr:`GenomicRange.start` and</span>
<span class="sd">        :attr:`GenomicRange.end`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">between</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">GenomicRange</span><span class="p">):</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">pos</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">pos</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">))</span> <span class="ow">and</span> \
            <span class="p">(</span><span class="n">between</span><span class="p">(</span><span class="n">pos</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">))</span></div>

<div class="viewcode-block" id="GenomicRange.get_range"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.GenomicRange.get_range">[docs]</a>    <span class="k">def</span> <span class="nf">get_range</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Returns the start and end position as a tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span></div>

<div class="viewcode-block" id="GenomicRange.get_relative_pos"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.GenomicRange.get_relative_pos">[docs]</a>    <span class="k">def</span> <span class="nf">get_relative_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.16</span>

<span class="sd">        Given an absolute position (referred to the reference), convert the</span>
<span class="sd">        position to a coordinate relative to the GenomicRange</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: the position relative to the GenomicRange</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: if the position is not in the range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position </span><span class="si">{}</span><span class="s2"> not in GenomicRange&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="mi">1</span></div></div>


<div class="viewcode-block" id="Annotation"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation">[docs]</a><span class="k">class</span> <span class="nc">Annotation</span><span class="p">(</span><span class="n">GenomicRange</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    .. versionchanged:: 0.2.1</span>
<span class="sd">        using __slots__ for better memory usage</span>

<span class="sd">    Alternative implementation for an Annotation. When initialised, If *uid* is</span>
<span class="sd">    None, a unique id is added using `uuid.uuid4`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;attr&#39;</span><span class="p">)</span>

    <span class="c1"># source = &#39;None&#39;</span>
    <span class="c1"># &quot;Annotation source&quot;</span>
    <span class="c1"># feat_type = &#39;None&#39;</span>
    <span class="c1"># &quot;Annotation type (e.g. CDS, gene, exon, etc.)&quot;</span>
    <span class="c1"># score = 0.0</span>
    <span class="c1"># &quot;Score associated to the annotation&quot;</span>
    <span class="c1"># phase = 0</span>
    <span class="c1"># &quot;Annotation phase, (0, 1, 2)&quot;</span>
    <span class="c1"># attr = None</span>
    <span class="c1"># &quot;Dictionary with the key value pairs in the last column of a GFF/GTF&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_id</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">strand</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
                 <span class="n">source</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">feat_type</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">score</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">uid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">kwd</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Annotation</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">seq_id</span><span class="o">=</span><span class="n">seq_id</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
            <span class="n">strand</span><span class="o">=</span><span class="n">strand</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">source</span> <span class="o">=</span> <span class="n">source</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">feat_type</span> <span class="o">=</span> <span class="n">feat_type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score</span> <span class="o">=</span> <span class="n">score</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase</span> <span class="o">=</span> <span class="n">phase</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span> <span class="o">=</span> <span class="n">kwd</span>

        <span class="k">if</span> <span class="n">uid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uid</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">uid</span>

    <span class="k">def</span> <span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">)</span>

<div class="viewcode-block" id="Annotation.get_ec"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.get_ec">[docs]</a>    <span class="k">def</span> <span class="nf">get_ec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        .. versionchanged:: 0.2.0</span>
<span class="sd">            returns a *set* instead of a list</span>

<span class="sd">        Returns the EC values associated with the annotation, cutting them at</span>
<span class="sd">        the desired level.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            level (int): level of classification desired (between 1 and 4)</span>

<span class="sd">        Returns:</span>
<span class="sd">            set: list of all EC numbers associated, at the desired level, if</span>
<span class="sd">            none are found an empty set is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;EC&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">set</span><span class="p">()</span>

        <span class="n">ec</span> <span class="o">=</span> <span class="n">ec</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;.&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)[:</span><span class="n">level</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ec</span><span class="p">])</span></div>

<div class="viewcode-block" id="Annotation.get_mapping"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.get_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">get_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Returns the mappings, to a particular db, associated with the</span>
<span class="sd">        annotation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            db (str): database to which the mappings come from</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: list of all mappings associated, to the specified db, if</span>
<span class="sd">            none are found an empty list is returned</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mappings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;map_</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">upper</span><span class="p">()))</span>
        <span class="k">if</span> <span class="n">mappings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">return</span> <span class="n">mappings</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.set_mapping"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.set_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">set_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">values</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Set mappings to a particular db, associated with the</span>
<span class="sd">        annotation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            db (str): database to which the mappings come from</span>
<span class="sd">            mappings (iterable): iterable of mappings</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span>
            <span class="s1">&#39;map_</span><span class="si">{0}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">db</span><span class="o">.</span><span class="n">upper</span><span class="p">()),</span>
            <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.get_mappings"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.get_mappings">[docs]</a>    <span class="k">def</span> <span class="nf">get_mappings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.1</span>

<span class="sd">        Return a dictionary where the keys are the mapping DBs (lowercase) and</span>
<span class="sd">        and the values are the mapping IDs for that DB</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mappings</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;map_&#39;</span><span class="p">):</span>
                <span class="n">db</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;map_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">mappings</span><span class="p">[</span><span class="n">db</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mapping</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mappings</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">taxon_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionchanged:: 0.3.1</span>
<span class="sd">            if taxon_id is set to &quot;None&quot; as a string, it&#39;s converted to *None*</span>

<span class="sd">        taxon_id of the annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;taxon_id&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">TypeError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@taxon_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">taxon_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;taxon_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">db</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;db used for the gene_id prediction&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;db&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@db</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;db&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">taxon_db</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;db used for the taxon_id prediction&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;taxon_db&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@taxon_db</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">taxon_db</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;taxon_db&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dbq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;db quality of the annotation&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="s1">&#39;dbq&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">AttributeNotFound</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@dbq</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">dbq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;dbq&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">uid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        uid of the annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;uid&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># old data where the unique id is marked as ko_idx</span>
            <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ko_idx&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">value</span>

    <span class="nd">@uid</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">uid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;uid&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">bitscore</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;bitscore of the annotation&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;bitscore&#39;</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># legacy for old data</span>
            <span class="n">bitscore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;bit_score&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">bitscore</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">bitscore</span><span class="p">)</span>

    <span class="nd">@bitscore</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">bitscore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;bitscore&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">gene_id</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="s2">&quot;gene_id of the annotation, or *ko* if available&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;gene_id&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># legacy for old data</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;ko&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="nd">@gene_id</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">gene_id</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;gene_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionchanged:: 0.2.0</span>

<span class="sd">        Length of the annotation, uses `len(self)`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">region</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Return the *region* covered by the annotation, to use in samtools</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="s2">:</span><span class="si">{1}</span><span class="s2">:</span><span class="si">{2}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">counts</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.2</span>

<span class="sd">        Returns the sample counts for the annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;counts_&#39;</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;counts_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">counts</span>

    <span class="nd">@counts</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">counts</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">counts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.2</span>

<span class="sd">        Sets the sample counts for the annotation</span>

<span class="sd">        Arguments:</span>
<span class="sd">            counts (dict): key is the sample name and the count for it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">counts</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s2">&quot;counts_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fpkms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.2</span>

<span class="sd">        Returns the sample fpkms for the annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fpkms</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;fpkms_&#39;</span><span class="p">):</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;fpkms_&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="n">fpkms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">fpkms</span>

    <span class="nd">@fpkms</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">fpkms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fpkms</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.2</span>

<span class="sd">        Sets the sample fpkms for the annotation</span>

<span class="sd">        Arguments:</span>
<span class="sd">            fpkms (dict): key is the sample name and the fpmk for it</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">fpkms</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s2">&quot;fpkms_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">value</span>

<div class="viewcode-block" id="Annotation.add_exp_syn_count"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.add_exp_syn_count">[docs]</a>    <span class="k">def</span> <span class="nf">add_exp_syn_count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">syn_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Adds expected synonymous/non-synonymous values for an annotation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            seq (str): sequence corresponding to the annotation seq_id</span>
<span class="sd">                syn_matrix (None, dict): matrix that determines the return</span>
<span class="sd">                values. Defaults to the one defined in the called function</span>
<span class="sd">                :func:`mgkit.utils.sequnce.get_seq_expected_syn_count`.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nuc_seq</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span>

        <span class="n">syn_count</span><span class="p">,</span> <span class="n">nonsyn_count</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">get_seq_expected_syn_count</span><span class="p">(</span>
            <span class="n">seq</span><span class="p">,</span>
            <span class="n">syn_matrix</span><span class="o">=</span><span class="n">syn_matrix</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;exp_syn&#39;</span><span class="p">,</span> <span class="n">syn_count</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;exp_nonsyn&#39;</span><span class="p">,</span> <span class="n">nonsyn_count</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.to_gff"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.to_gff">[docs]</a>    <span class="k">def</span> <span class="nf">to_gff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;=&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Format the Annotation as a GFF string.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            sep (str): separator key -&gt; value</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: annotation formatted as GFF</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span>
            <span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span>
        <span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">var_names</span>
        <span class="p">)</span>

        <span class="n">attr_column</span> <span class="o">=</span> <span class="s1">&#39;;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">{0}{1}</span><span class="s1">&quot;</span><span class="si">{2}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">sep</span><span class="p">,</span>
                <span class="n">quote</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="s1">&#39; ()/&#39;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="se">\t</span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">attr_column</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.to_dict"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">exclude_attr</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.3.1</span>

<span class="sd">        Return a dictionary representation of the Annotation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            exclude_attr (str,list): attributes to exclude from the dictionary,</span>
<span class="sd">                can be either a single attribute (string) or a list of strings</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: dictionary with the annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span>
            <span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span>
        <span class="p">)</span>

        <span class="n">dictionary</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

        <span class="n">dictionary</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">exclude_attr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exclude_attr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">exclude_attr</span> <span class="o">=</span> <span class="p">[</span><span class="n">exclude_attr</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">exclude_attr</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">dictionary</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dictionary</span></div>

<div class="viewcode-block" id="Annotation.to_json"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.to_json">[docs]</a>    <span class="k">def</span> <span class="nf">to_json</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.1</span>

<span class="sd">        .. versionchanged:: 0.3.1</span>
<span class="sd">            now :meth:`Annotation.to_dict` is used</span>

<span class="sd">        Returns a json representation of the Annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(),</span> <span class="n">separators</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Annotation.to_mongodb"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.to_mongodb">[docs]</a>    <span class="k">def</span> <span class="nf">to_mongodb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lineage_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">raw</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.1</span>

<span class="sd">        .. versionchanged:: 0.2.2</span>
<span class="sd">            added handling of *counts_* and *fpkms_*</span>

<span class="sd">        .. versionchanged:: 0.2.6</span>
<span class="sd">            added *indent* parameter</span>

<span class="sd">        .. versionchanged:: 0.3.4</span>
<span class="sd">            added *raw*</span>

<span class="sd">        Returns a MongoDB document that represent the Annotation.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            lineage (func): function used to populate the lineage key, returns</span>
<span class="sd">                a list of taxon_id</span>
<span class="sd">            indent (int): the amount of indent to put in the record, None (the</span>
<span class="sd">                default) is for the most compact - one line for the record</span>
<span class="sd">            raw (bool): if True, the method returns a string, which is the</span>
<span class="sd">                json dump, if False, the value returned is the dictionary</span>

<span class="sd">        Returns:</span>
<span class="sd">            str or dict: the MongoDB document, with Annotation.uid as _id, as</span>
<span class="sd">            a string if *raw* is True, a dictionary if it is False</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># OrderedDict is necessary to keep the order of the keys</span>
        <span class="n">dictionary</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>

        <span class="c1"># _id must be the first element</span>
        <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span>

        <span class="n">var_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="s1">&#39;strand&#39;</span><span class="p">,</span>
            <span class="s1">&#39;phase&#39;</span><span class="p">,</span> <span class="s1">&#39;gene_id&#39;</span><span class="p">,</span> <span class="s1">&#39;taxon_id&#39;</span><span class="p">,</span> <span class="s1">&#39;bitscore&#39;</span><span class="p">,</span> <span class="s1">&#39;exp_nonsyn&#39;</span><span class="p">,</span>
            <span class="s1">&#39;exp_syn&#39;</span><span class="p">,</span> <span class="s1">&#39;length&#39;</span><span class="p">,</span> <span class="s1">&#39;dbq&#39;</span><span class="p">,</span> <span class="s1">&#39;coverage&#39;</span><span class="p">,</span> <span class="s1">&#39;uid&#39;</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">dictionary</span><span class="p">[</span><span class="n">var_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">AttributeNotFound</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="n">ec_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ec</span><span class="p">()</span>
        <span class="n">mappings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mappings</span><span class="p">()</span>

        <span class="c1"># if one at least has values</span>
        <span class="k">if</span> <span class="n">ec_ids</span><span class="p">:</span>
            <span class="n">mappings</span><span class="p">[</span><span class="s1">&#39;ec&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ec_ids</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lineage_func</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;lineage&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">lineage_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">taxon_id</span><span class="p">)</span>

        <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mappings</span>

        <span class="n">counts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">counts</span>
        <span class="k">if</span> <span class="n">counts</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;counts&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span>

        <span class="n">fpkms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fpkms</span>
        <span class="k">if</span> <span class="n">fpkms</span><span class="p">:</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="s1">&#39;fpkms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fpkms</span>

        <span class="c1"># the rest of the dictionary should be put, excluding special keys:</span>
        <span class="c1"># uid is used as _id in the document</span>
        <span class="c1"># EC is put as a array, as is any mapping like map_KO</span>
        <span class="n">dictionary</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="nb">dict</span><span class="p">(</span>
                <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">var_names</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;uid&#39;</span><span class="p">,</span> <span class="s1">&#39;EC&#39;</span><span class="p">))</span> <span class="ow">and</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;map_&#39;</span><span class="p">))</span> <span class="ow">and</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;counts_&#39;</span><span class="p">))</span> <span class="ow">and</span>
                <span class="p">(</span><span class="ow">not</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;fpkms_&#39;</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">raw</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">dictionary</span>

        <span class="k">return</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">indent</span><span class="o">=</span><span class="n">indent</span><span class="p">,</span> <span class="n">separators</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="s1">&#39;:&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Annotation.to_file"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_handle</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the GFF annotation to *file_handle*</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">file_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_gff</span><span class="p">()</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span></div>

<div class="viewcode-block" id="Annotation.to_gtf"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.to_gtf">[docs]</a>    <span class="k">def</span> <span class="nf">to_gtf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gene_id_attr</span><span class="o">=</span><span class="s1">&#39;uid&#39;</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39; &#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.15</span>

<span class="sd">        .. versionchanged:: 0.1.16</span>
<span class="sd">            added *gene_id_attr* parameter</span>

<span class="sd">        .. versionchanged:: 0.2.2</span>
<span class="sd">            added *sep* argument, default to a space, now</span>

<span class="sd">        Simple conversion to a valid GTF. gene_id and transcript_id are set to</span>
<span class="sd">        *uid* or the attribute specified using the *gene_id_attr* parameter.</span>
<span class="sd">        It&#39;s written to be used with *SNPDat*.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">var_names</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span>
            <span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span>
        <span class="p">)</span>

        <span class="n">values</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="nb">str</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">var_name</span> <span class="ow">in</span> <span class="n">var_names</span>
        <span class="p">)</span>

        <span class="c1"># Keys that needs to be at the start of the attributes</span>
        <span class="n">gtf_attr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;gene_id&#39;</span><span class="p">,</span> <span class="s1">&#39;transcript_id&#39;</span><span class="p">]</span>

        <span class="n">attr_keys</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="c1"># eliminate gene_id (always present in new ones)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr_keys</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;gene_id&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="c1"># transcript_id don&#39;t always be there</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr_keys</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;transcript_id&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="n">attr_values</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="n">gene_id_attr</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="n">attr_key</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">attr_key</span> <span class="ow">in</span> <span class="n">attr_keys</span>
        <span class="p">]</span>
        <span class="n">attr_keys</span> <span class="o">=</span> <span class="n">gtf_attr</span> <span class="o">+</span> <span class="n">attr_keys</span>

        <span class="n">attr_column</span> <span class="o">=</span> <span class="s1">&#39;; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">&#39;</span><span class="si">{0}{1}</span><span class="s1">&quot;</span><span class="si">{2}</span><span class="s1">&quot;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">key</span><span class="p">,</span>
                <span class="n">sep</span><span class="p">,</span>
                <span class="n">quote</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="s1">&#39; ()/&#39;</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">attr_keys</span><span class="p">,</span> <span class="n">attr_values</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{0}</span><span class="se">\t</span><span class="si">{1}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">values</span><span class="p">,</span> <span class="n">attr_column</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">sample_coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Returns a dictionary with the coverage for each sample, the returned</span>
<span class="sd">        dictionary has the sample id (stripped of the *_cov*) suffix and as</span>
<span class="sd">        values the coverage (converted via :func:`int`).</span>

<span class="sd">        :return dict: dictionary with the samples&#39; coverage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">attributes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span>

        <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">attribute</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_cov&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">),</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">attribute</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">attributes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">attribute</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;_cov&#39;</span><span class="p">)</span>
        <span class="p">)</span>

<div class="viewcode-block" id="Annotation.get_number_of_samples"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.get_number_of_samples">[docs]</a>    <span class="k">def</span> <span class="nf">get_number_of_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_cov</span><span class="o">=</span><span class="n">MIN_COV</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Returns the number of sample that have at least a minimum coverage of</span>
<span class="sd">        `min_cov`.</span>

<span class="sd">        :param int min_cov: minimum coverage</span>
<span class="sd">        :return int: number of samples passing the filter</span>
<span class="sd">        :raise AttributeNotFound: if no sample coverage attribute is found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coverage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sample_coverage</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">coverage</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">AttributeNotFound</span><span class="p">(</span>
                <span class="s1">&#39;No coverage attribute found (ending in &quot;_cov&quot;)&#39;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span>
            <span class="mi">1</span> <span class="k">for</span> <span class="n">sample</span><span class="p">,</span> <span class="n">coverage</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">coverage</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">coverage</span> <span class="o">&gt;=</span> <span class="n">min_cov</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.get_attr"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.get_attr">[docs]</a>    <span class="k">def</span> <span class="nf">get_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">conv</span><span class="o">=</span><span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        .. versionchanged:: 0.3.4</span>
<span class="sd">            any GFF attribute can be returned</span>

<span class="sd">        .. versionchanged:: 0.3.3</span>
<span class="sd">            added *seq_id* as special attribute, in addition do *length*</span>

<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Generic method to get an attribute and convert it to a specific</span>
<span class="sd">        datatype. The order for the lookup is:</span>

<span class="sd">        * length</span>
<span class="sd">        * self.attr (dictionary)</span>
<span class="sd">        * getattr(self) of the first 8 columns of a GFF (seq_id, source, ...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">conv</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">):</span>
            <span class="n">value</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">conv</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">raise</span> <span class="n">AttributeNotFound</span><span class="p">(</span><span class="s1">&#39;No </span><span class="si">{0}</span><span class="s1"> attribute found&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">attr</span><span class="p">))</span></div>

<div class="viewcode-block" id="Annotation.set_attr"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.set_attr">[docs]</a>    <span class="k">def</span> <span class="nf">set_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        .. versionchanged:: 0.4.4</span>
<span class="sd">            a standard attribute can now be set</span>

<span class="sd">        Generic method to set an attribute</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>

<div class="viewcode-block" id="Annotation.has_attr"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.has_attr">[docs]</a>    <span class="k">def</span> <span class="nf">has_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.4.4</span>

<span class="sd">        Tests if an attributes is present in the Annotation</span>

<span class="sd">        Arguments:</span>
<span class="sd">            attr (str): attribute to test</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the attributes is present</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">attr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span></div>

<div class="viewcode-block" id="Annotation.del_attr"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.del_attr">[docs]</a>    <span class="k">def</span> <span class="nf">del_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.4.4</span>

<span class="sd">        Removes attributes from the Annotation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">attr</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span> <span class="s1">&#39;score&#39;</span><span class="p">,</span>
                    <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="n">attr</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">coverage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Return the total coverage for the annotation</span>

<span class="sd">        :return float: coverage</span>
<span class="sd">        :raise AttributeNotFound: if no coverage attribute is found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="s1">&#39;cov&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exp_syn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Returns the expected number of synonymous changes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="s1">&#39;exp_syn&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">exp_nonsyn</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        Returns the expected number of non-synonymous changes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="s1">&#39;exp_nonsyn&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span>

<div class="viewcode-block" id="Annotation.get_nuc_seq"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.get_nuc_seq">[docs]</a>    <span class="k">def</span> <span class="nf">get_nuc_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">snp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.13</span>

<span class="sd">        .. versionchanged:: 0.1.16</span>
<span class="sd">            added *snp* parameter</span>

<span class="sd">        Returns the nucleotidic sequence that the annotation covers. if the</span>
<span class="sd">        annotation&#39;s strand is *-*, and *reverse* is True, the reverse</span>
<span class="sd">        complement is returned.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            seq (seq): chromosome/contig sequence</span>
<span class="sd">            reverse (bool): if True and the strand is &#39;-&#39;, a reverse complement</span>
<span class="sd">                is returned</span>
<span class="sd">            snp (tuple): first element is the position of the SNP relative to</span>
<span class="sd">                the Annotation and the second element is the change</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: nucleotide sequence with requested transformations</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ann_seq</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="bp">self</span><span class="o">.</span><span class="n">end</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">snp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ann_seq</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">get_variant_sequence</span><span class="p">(</span><span class="n">ann_seq</span><span class="p">,</span> <span class="n">snp</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">reverse</span><span class="p">:</span>
            <span class="n">ann_seq</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">(</span><span class="n">ann_seq</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ann_seq</span></div>

<div class="viewcode-block" id="Annotation.get_aa_seq"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.get_aa_seq">[docs]</a>    <span class="k">def</span> <span class="nf">get_aa_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">snp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.16</span>

<span class="sd">        Returns a translated aminoacid sequence of the annotation. The snp</span>
<span class="sd">        parameter is passed to :meth:`Annotation.get_nuc_seq`</span>

<span class="sd">        Arguments:</span>
<span class="sd">            seq (seq): chromosome/contig sequence</span>
<span class="sd">            start (int): position (0-based) from where the correct occurs</span>
<span class="sd">                (frame). If None, the phase attribute is used</span>
<span class="sd">            tbl (dict): dictionary with the translation for each codon,</span>
<span class="sd">                passed to :func:`mgkit.utils.sequence.translate_sequence`</span>
<span class="sd">            snp (tuple): first element is the position of the SNP and the</span>
<span class="sd">                second element is the change</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: aminoacid sequence</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase</span>

        <span class="n">nuc_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nuc_seq</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">snp</span><span class="o">=</span><span class="n">snp</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">translate_sequence</span><span class="p">(</span>
            <span class="n">nuc_seq</span><span class="p">,</span>
            <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
            <span class="n">tbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.add_gc_content"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.add_gc_content">[docs]</a>    <span class="k">def</span> <span class="nf">add_gc_content</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds GC content information for an annotation. The formula is:</span>

<span class="sd">        .. math::</span>
<span class="sd">            :label: gc_content_gff</span>

<span class="sd">            \\frac {(G + C)}{(G + C + A + T)}</span>

<span class="sd">        Modifies the instances of the annotation. gc_ratio will be added to its</span>
<span class="sd">        attributes.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            seq (str): nucleotide sequence referred in the GFF</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ann_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nuc_seq</span><span class="p">(</span>
            <span class="n">seq</span><span class="p">,</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="p">)</span>

        <span class="n">at_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">ann_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">ann_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">))</span>
        <span class="n">gc_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">ann_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">ann_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">))</span>

        <span class="n">gc_cont</span> <span class="o">=</span> <span class="n">gc_sum</span> <span class="o">/</span> <span class="p">(</span><span class="n">gc_sum</span> <span class="o">+</span> <span class="n">at_sum</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;gc_cont&#39;</span><span class="p">,</span> <span class="n">gc_cont</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.add_gc_ratio"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.add_gc_ratio">[docs]</a>    <span class="k">def</span> <span class="nf">add_gc_ratio</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds GC content information for an annotation. The formula is:</span>

<span class="sd">        .. math::</span>
<span class="sd">            :label: gc_ratio_gff</span>

<span class="sd">            \\frac {(A + T)}{(G + C)}</span>

<span class="sd">        Modifies the instances of the annotation. gc_ratio will be added to its</span>
<span class="sd">        attributes.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            seq (str): nucleotide sequence referred in the GFF</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ann_seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_nuc_seq</span><span class="p">(</span>
            <span class="n">seq</span><span class="p">,</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="p">)</span>

        <span class="n">at_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">ann_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">ann_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">))</span>
        <span class="n">gc_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">ann_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;G&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">ann_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">))</span>

        <span class="n">gc_ratio</span> <span class="o">=</span> <span class="n">at_sum</span> <span class="o">/</span> <span class="n">gc_sum</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;gc_ratio&#39;</span><span class="p">,</span> <span class="n">gc_ratio</span><span class="p">)</span></div>

<div class="viewcode-block" id="Annotation.is_syn"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.Annotation.is_syn">[docs]</a>    <span class="k">def</span> <span class="nf">is_syn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">change</span><span class="p">,</span> <span class="n">tbl</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">abs_pos</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
               <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.1.16</span>

<span class="sd">        .. versionchanged:: 0.4.4</span>
<span class="sd">            added *strict* parameter</span>

<span class="sd">        Return if a SNP is synonymous or non-synonymous.</span>

<span class="sd">        Arguments:</span>
<span class="sd">            seq (seq): reference sequence of the annotation</span>
<span class="sd">            pos (int): position of the SNP on the reference (1-based index)</span>
<span class="sd">            change (str): nucleotidic change</span>
<span class="sd">            tbl (dict): dictionary with the translation table. Defaults to the</span>
<span class="sd">                universal genetic code</span>
<span class="sd">            abs_pos (bool): if True the *pos* is referred to the reference and</span>
<span class="sd">                not a position relative to the annotation</span>
<span class="sd">            start (int or None): phase to be used to get the start position of</span>
<span class="sd">                the codon. if None, the Annotation phase will be used</span>
<span class="sd">            strict (bool): if a variant codon is not found, a KeyError is</span>
<span class="sd">                raised, otherwise *False* is returned</span>

<span class="sd">        Returns:</span>
<span class="sd">            bool: True if the SNP is synonymous, false if it&#39;s non-synonymous.</span>
<span class="sd">            Behaviour in case of variant codons not found in the translation</span>
<span class="sd">            table changes based on *strict*</span>

<span class="sd">        Raises:</span>
<span class="sd">            KeyError: if the variant codon is not found and *strict* is True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">abs_pos</span><span class="p">:</span>
            <span class="n">rel_pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_relative_pos</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">rel_pos</span> <span class="o">=</span> <span class="n">pos</span>

        <span class="k">if</span> <span class="n">start</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase</span>

        <span class="k">if</span> <span class="n">tbl</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tbl</span> <span class="o">=</span> <span class="n">UNIVERSAL</span>

        <span class="c1"># codon number in the sequence</span>
        <span class="n">codon_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">rel_pos</span> <span class="o">-</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">3</span>
        <span class="c1"># the position to slice the seq to get a codon (0-based). It takes into</span>
        <span class="c1"># account the phase (start) and the codon index</span>
        <span class="n">seq_start</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">start</span> <span class="o">+</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">codon_index</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># position in the codon using the relative position and the phase/frame</span>
        <span class="c1"># the module will give 1, 2 or 0. -1 will shift the position correctly</span>
        <span class="n">codon_change</span> <span class="o">=</span> <span class="p">((</span><span class="n">rel_pos</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">codon</span> <span class="o">=</span> <span class="n">seq</span><span class="p">[</span><span class="n">seq_start</span><span class="p">:</span><span class="n">seq_start</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span>

        <span class="n">var_codon</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">codon</span><span class="p">)</span>
        <span class="n">var_codon</span><span class="p">[</span><span class="n">codon_change</span><span class="p">]</span> <span class="o">=</span> <span class="n">change</span>
        <span class="n">var_codon</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">var_codon</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
            <span class="n">codon</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">(</span><span class="n">codon</span><span class="p">)</span>
            <span class="n">var_codon</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">(</span><span class="n">var_codon</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">UNIVERSAL</span><span class="p">[</span><span class="n">codon</span><span class="p">]</span> <span class="o">==</span> <span class="n">UNIVERSAL</span><span class="p">[</span><span class="n">var_codon</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">LOG</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;Annotation </span><span class="si">%s</span><span class="s2"> has an unrecognised codon:</span>
<span class="s2">                        reference </span><span class="si">%s</span><span class="s2">, variant </span><span class="si">%s</span><span class="s2">&quot;&quot;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span> <span class="n">codon</span><span class="p">,</span>
                        <span class="n">var_codon</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">strict</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span><span class="s2">&quot;Variant codon not found </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">var_codon</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span></div></div>


<div class="viewcode-block" id="from_glimmer3"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_glimmer3">[docs]</a><span class="k">def</span> <span class="nf">from_glimmer3</span><span class="p">(</span><span class="n">header</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="n">feat_type</span><span class="o">=</span><span class="s1">&#39;CDS&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    Parses the line of a GLIMMER3 ouput and returns an instance of a GFF</span>
<span class="sd">    annotation.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        header (str): the seq_id to which the ORF belongs</span>
<span class="sd">        line (str): the prediction line for the orf</span>
<span class="sd">        feat_type (str): the feature type to use</span>

<span class="sd">    Returns:</span>
<span class="sd">        Annotation: instance of annotation</span>

<span class="sd">    Example:</span>
<span class="sd">        Assuming a GLIMMER3 output like this::</span>

<span class="sd">            &gt;sequence0001</span>
<span class="sd">            orf00001       66      611  +3     6.08</span>

<span class="sd">        The code used is:</span>

<span class="sd">        &gt;&gt;&gt; header = &#39;sequence0001&#39;</span>
<span class="sd">        &gt;&gt;&gt; line = &#39;orf00001       66      611  +3     6.08&#39;</span>
<span class="sd">        &gt;&gt;&gt; from_glimmer3(header, line)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
    <span class="n">orf_id</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">frame</span><span class="p">,</span> <span class="n">score</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="n">start</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span>

    <span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span>
        <span class="n">seq_id</span><span class="o">=</span><span class="n">header</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="s1">&#39;GLIMMER3&#39;</span><span class="p">,</span>
        <span class="n">feat_type</span><span class="o">=</span><span class="n">feat_type</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
        <span class="n">score</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">score</span><span class="p">),</span>
        <span class="n">strand</span><span class="o">=</span><span class="n">frame</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">phase</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span>
        <span class="n">glimmer_score</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">score</span><span class="p">),</span>
        <span class="n">orf_id</span><span class="o">=</span><span class="n">orf_id</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">annotation</span></div>


<div class="viewcode-block" id="DuplicateKeyError"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.DuplicateKeyError">[docs]</a><span class="k">class</span> <span class="nc">DuplicateKeyError</span><span class="p">(</span><span class="ne">Exception</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    Raised if a GFF annotation contains duplicate keys</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">pass</span></div>


<div class="viewcode-block" id="from_gff"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_gff">[docs]</a><span class="k">def</span> <span class="nf">from_gff</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    .. versionchanged:: 0.2.6</span>
<span class="sd">        added *strict* parameter</span>

<span class="sd">    .. versionchanged:: 0.4.0</span>
<span class="sd">        added *encoding* parameter</span>

<span class="sd">    Parse GFF line and returns an :class:`Annotation` instance</span>

<span class="sd">    Arguments:</span>
<span class="sd">        line (str): GFF line</span>
<span class="sd">        strict (bool): if True duplicate keys raise an exception</span>

<span class="sd">    Returns:</span>
<span class="sd">        Annotation: instance of :class:`Annotation` for the line</span>

<span class="sd">    Raises:</span>
<span class="sd">        DuplicateKeyError: if the attribute column has duplicate keys</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># in case the last column (attributes) is empty</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">line</span>
        <span class="c1"># bug in which the phase was not written</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">line</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">line</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">var_names</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s1">&#39;seq_id&#39;</span><span class="p">,</span> <span class="s1">&#39;source&#39;</span><span class="p">,</span> <span class="s1">&#39;feat_type&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;end&#39;</span><span class="p">,</span>
        <span class="s1">&#39;score&#39;</span><span class="p">,</span> <span class="s1">&#39;strand&#39;</span><span class="p">,</span> <span class="s1">&#39;phase&#39;</span>
    <span class="p">)</span>
    <span class="c1"># the phase sometimes can be set as unknown, using &#39;-&#39;. We prefer using 0</span>
    <span class="n">var_types</span> <span class="o">=</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span>
                 <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span> <span class="k">else</span> <span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="n">attr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">vtype</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">var_names</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">var_types</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">attr</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">vtype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">attr</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="c1"># in case the last column (attributes) is empty</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">9</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">Annotation</span><span class="p">(</span><span class="o">**</span><span class="n">attr</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">line</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># by default the key,value separator &#39;=&#39; is assumed to be used</span>
            <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="c1"># in case it doesn&#39;t work, it is assumed to be a space</span>
            <span class="k">if</span> <span class="s1">&#39; &#39;</span> <span class="ow">in</span> <span class="n">pair</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">var</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># case in which there&#39;s an attribute but no value, like a bool</span>
                <span class="n">var</span> <span class="o">=</span> <span class="n">pair</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="n">value</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">var</span> <span class="ow">in</span> <span class="n">attr</span><span class="p">)</span> <span class="ow">and</span> <span class="n">strict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">DuplicateKeyError</span><span class="p">(</span><span class="s2">&quot;Duplicate attribute: </span><span class="si">{0}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">var</span><span class="p">))</span>

        <span class="c1"># skips possible key/values generated by the line ending with a &#39;;&#39;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">var</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">unquote</span><span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;&quot;&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">))</span>
        <span class="n">attr</span><span class="p">[</span><span class="n">var</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="k">return</span> <span class="n">Annotation</span><span class="p">(</span><span class="o">**</span><span class="n">attr</span><span class="p">)</span></div>


<div class="viewcode-block" id="from_sequence"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_sequence">[docs]</a><span class="k">def</span> <span class="nf">from_sequence</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">feat_type</span><span class="o">=</span><span class="s1">&#39;SEQUENCE&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    Returns an instance of :class:`Annotation` for the full length of a</span>
<span class="sd">    sequence</span>

<span class="sd">    Arguments:</span>
<span class="sd">        name (str): name of the sequence</span>
<span class="sd">        seq (str): sequence, to get the length of the annotation</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        feat_type (str): feature type in the GFF</span>
<span class="sd">        **kwd: any additional column</span>

<span class="sd">    Returns:</span>
<span class="sd">        Annotation: instance of :class:`Annotation`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span>
        <span class="n">seq_id</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="s1">&#39;SEQUENCE&#39;</span><span class="p">,</span>
        <span class="n">feat_type</span><span class="o">=</span><span class="n">feat_type</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span>
        <span class="n">score</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=</span><span class="s1">&#39;+&#39;</span><span class="p">,</span>
        <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">sequence</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwd</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">annotation</span></div>


<div class="viewcode-block" id="from_aa_blast_frag"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_aa_blast_frag">[docs]</a><span class="k">def</span> <span class="nf">from_aa_blast_frag</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">parent_ann</span><span class="p">,</span> <span class="n">aa_seqs</span><span class="p">):</span>
    <span class="n">frag_id</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">)</span>
    <span class="n">strand</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span> <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;f&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;-&#39;</span>
    <span class="n">frame</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">identity</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">bitscore</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;-&#39;</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">reverse_aa_coord</span><span class="p">(</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">aa_seqs</span><span class="p">[</span><span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="p">)</span>
    <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">convert_aa_to_nuc_coord</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">frame</span><span class="p">)</span>

    <span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span>
        <span class="n">seq_id</span><span class="o">=</span><span class="n">parent_ann</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="s1">&#39;BLAST&#39;</span><span class="p">,</span>
        <span class="n">feat_type</span><span class="o">=</span><span class="s1">&#39;CDS&#39;</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span> <span class="o">+</span> <span class="n">parent_ann</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">end</span> <span class="o">+</span> <span class="n">parent_ann</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">score</span><span class="o">=</span><span class="n">bitscore</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=</span><span class="n">strand</span><span class="p">,</span>
        <span class="n">phase</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span>
        <span class="n">db</span><span class="o">=</span><span class="s1">&#39;UNIPROT&#39;</span><span class="p">,</span>
        <span class="n">gene_id</span><span class="o">=</span><span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">identity</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span>
        <span class="n">bitscore</span><span class="o">=</span><span class="n">bitscore</span><span class="p">,</span>
        <span class="n">ID</span><span class="o">=</span><span class="n">frag_id</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">annotation</span></div>


<div class="viewcode-block" id="from_nuc_blast_frag"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_nuc_blast_frag">[docs]</a><span class="k">def</span> <span class="nf">from_nuc_blast_frag</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">parent_ann</span><span class="p">,</span> <span class="n">db</span><span class="o">=</span><span class="s1">&#39;NCBI-NT&#39;</span><span class="p">):</span>
    <span class="n">frag_id</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">strand</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
    <span class="n">identity</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">bitscore</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>

    <span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span>
        <span class="n">seq_id</span><span class="o">=</span><span class="n">parent_ann</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="s1">&#39;BLAST&#39;</span><span class="p">,</span>
        <span class="n">feat_type</span><span class="o">=</span><span class="s1">&#39;CDS&#39;</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span> <span class="o">+</span> <span class="n">parent_ann</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">end</span> <span class="o">+</span> <span class="n">parent_ann</span><span class="o">.</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">score</span><span class="o">=</span><span class="n">bitscore</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=</span><span class="n">strand</span><span class="p">,</span>
        <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="n">db</span><span class="o">=</span><span class="n">db</span><span class="p">,</span>
        <span class="n">gene_id</span><span class="o">=</span><span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="n">identity</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span>
        <span class="n">bitscore</span><span class="o">=</span><span class="n">bitscore</span><span class="p">,</span>
        <span class="n">ID</span><span class="o">=</span><span class="n">frag_id</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">annotation</span></div>


<div class="viewcode-block" id="annotate_sequence"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.annotate_sequence">[docs]</a><span class="k">def</span> <span class="nf">annotate_sequence</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

    <span class="n">length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">window</span> <span class="o">=</span> <span class="n">length</span>

    <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">window</span><span class="p">):</span>
        <span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="o">.</span><span class="n">from_sequence</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">index</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">index</span> <span class="o">+</span> <span class="n">window</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">length</span><span class="p">:</span>
            <span class="n">annotation</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">length</span>
        <span class="k">yield</span> <span class="n">annotation</span></div>


<div class="viewcode-block" id="from_nuc_blast"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_nuc_blast">[docs]</a><span class="k">def</span> <span class="nf">from_nuc_blast</span><span class="p">(</span><span class="n">hit</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">feat_type</span><span class="o">=</span><span class="s1">&#39;CDS&#39;</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">to_nuc</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">kwd</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    .. versionchanged:: 0.1.16</span>
<span class="sd">        added *to_nuc* parameter</span>

<span class="sd">    .. versionchanged:: 0.2.3</span>
<span class="sd">        removed *to_nuc*, the hit can include the subject end/start and evalue</span>

<span class="sd">    Returns an instance of :class:`Annotation`</span>

<span class="sd">    Arguments:</span>
<span class="sd">        hit (tuple): a BLAST hit, from :func:`mgkit.io.blast.parse_blast_tab`</span>
<span class="sd">        db (str): db used with BLAST</span>

<span class="sd">    Keyword Args:</span>
<span class="sd">        feat_type (str): feature type in the GFF</span>
<span class="sd">        seq_len (int): sequence length, if supplied, the phase for strand &#39;-&#39;</span>
<span class="sd">            can be assigned, otherwise is assigned a 0</span>
<span class="sd">        **kwd: any additional column</span>

<span class="sd">    Returns:</span>
<span class="sd">        Annotation: instance of :class:`Annotation`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seq_id</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">gene_id</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">strand</span> <span class="o">=</span> <span class="s1">&#39;+&#39;</span>
    <span class="n">identity</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">bitscore</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
    <span class="n">phase</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">if</span> <span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">:</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span>
        <span class="n">strand</span> <span class="o">=</span> <span class="s1">&#39;-&#39;</span>
        <span class="k">if</span> <span class="n">seq_len</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">seq_len</span> <span class="o">-</span> <span class="n">end</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>

    <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span><span class="p">:</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>

    <span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span>
        <span class="n">seq_id</span><span class="o">=</span><span class="n">seq_id</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="s1">&#39;BLAST&#39;</span><span class="p">,</span>
        <span class="n">feat_type</span><span class="o">=</span><span class="n">feat_type</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="n">start</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">end</span><span class="p">,</span>
        <span class="n">score</span><span class="o">=</span><span class="n">bitscore</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=</span><span class="n">strand</span><span class="p">,</span>
        <span class="n">phase</span><span class="o">=</span><span class="n">phase</span><span class="p">,</span>
        <span class="n">db</span><span class="o">=</span><span class="n">db</span><span class="p">,</span>
        <span class="n">gene_id</span><span class="o">=</span><span class="n">gene_id</span><span class="p">,</span>
        <span class="n">identity</span><span class="o">=</span><span class="n">identity</span><span class="p">,</span>
        <span class="n">bitscore</span><span class="o">=</span><span class="n">bitscore</span><span class="p">,</span>
        <span class="n">frame</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;f&#39;</span> <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="s1">&#39;+&#39;</span> <span class="k">else</span> <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">phase</span><span class="p">),</span>
        <span class="o">**</span><span class="n">kwd</span>
    <span class="p">)</span>

    <span class="c1"># the hit includes subject end/start and evalue, as per new version of</span>
    <span class="c1"># mgkit.io.blast.parse_uniprot_blast</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hit</span><span class="p">)</span> <span class="o">==</span> <span class="mi">9</span><span class="p">:</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;evalue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;subject_end&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">]</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;subject_start&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hit</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">annotation</span></div>


<div class="viewcode-block" id="from_json"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_json">[docs]</a><span class="k">def</span> <span class="nf">from_json</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        .. versionadded:: 0.2.1</span>

<span class="sd">        Returns an Annotation from a json representation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">Annotation</span><span class="p">(</span><span class="o">**</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">line</span><span class="p">))</span></div>


<div class="viewcode-block" id="from_hmmer"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_hmmer">[docs]</a><span class="k">def</span> <span class="nf">from_hmmer</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">aa_seqs</span><span class="p">,</span> <span class="n">feat_type</span><span class="o">=</span><span class="s1">&#39;gene&#39;</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="s1">&#39;HMMER&#39;</span><span class="p">,</span>
               <span class="n">db</span><span class="o">=</span><span class="s1">&#39;CUSTOM&#39;</span><span class="p">,</span> <span class="n">custom_profiles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">noframe</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.15</span>
<span class="sd">        first implementation to move old scripts to new GFF specs</span>

<span class="sd">    .. versionchanged:: 0.2.1</span>
<span class="sd">        removed compatibility with old scripts</span>

<span class="sd">    .. versionchanged:: 0.2.2</span>
<span class="sd">        taxon_id and taxon_name are not saved for non-custom profiles</span>

<span class="sd">    .. versionchanged:: 0.3.1</span>
<span class="sd">        added support for non mgkit-translated sequences (*noframe*)</span>

<span class="sd">    Parse HMMER results (one line), it won&#39;t parse commented lines (starting</span>
<span class="sd">    with *#*)</span>

<span class="sd">    Arguments:</span>
<span class="sd">        line (str): HMMER domain table line</span>
<span class="sd">        aa_seqs (dict): dictionary with amino-acid sequences (name-&gt;seq),</span>
<span class="sd">            used to get the correct nucleotide positions</span>
<span class="sd">        feat_type (str): string to be used in the &#39;feature type&#39; column</span>
<span class="sd">        source (str): string to be used in the &#39;source&#39; column</span>
<span class="sd">        custom_profiles (bool): if True, the profile name contains gene,</span>
<span class="sd">            taxonomy and reviewed information in the form</span>
<span class="sd">            KOID_TAXONID_TAXON-NAME(-nr)</span>
<span class="sd">        noframe (bool): if True, the sequence is assumed to be in frame f0</span>

<span class="sd">    Returns:</span>
<span class="sd">        A :class:`Annotation` instance</span>

<span class="sd">    .. note::</span>

<span class="sd">        if `custom_profiles` is False, gene_id, taxon_id and taxon_name will</span>
<span class="sd">        be equal to the profile name</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">):</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">)</span>
    <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">noframe</span><span class="p">:</span>
        <span class="c1"># no information on the frame is provided (already a protein, so f0)</span>
        <span class="n">frame</span> <span class="o">=</span> <span class="s1">&#39;f0&#39;</span>
        <span class="n">contig</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">contig</span><span class="p">,</span> <span class="n">frame</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;-&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">t_from</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">17</span><span class="p">])</span>
    <span class="n">t_to</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">18</span><span class="p">])</span>
    <span class="c1"># first get coordinate if sequence is reversed</span>
    <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">):</span>
        <span class="n">seq_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aa_seqs</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">t_from</span><span class="p">,</span> <span class="n">t_to</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">reverse_aa_coord</span><span class="p">(</span><span class="n">t_from</span><span class="p">,</span> <span class="n">t_to</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>
    <span class="c1"># necessary only if frame information available</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">noframe</span><span class="p">:</span>
        <span class="c1"># converts in nucleotide coordinates</span>
        <span class="n">t_from</span><span class="p">,</span> <span class="n">t_to</span> <span class="o">=</span> <span class="n">seq_utils</span><span class="o">.</span><span class="n">convert_aa_to_nuc_coord</span><span class="p">(</span>
            <span class="n">t_from</span><span class="p">,</span>
            <span class="n">t_to</span><span class="p">,</span>
            <span class="n">frame</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="p">)</span>

    <span class="c1"># maintains the aa coordinates</span>
    <span class="n">aa_from</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">17</span><span class="p">])</span>
    <span class="n">aa_to</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">18</span><span class="p">])</span>
    <span class="n">profile_name</span> <span class="o">=</span> <span class="n">line</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">score</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">6</span><span class="p">])</span>

    <span class="k">if</span> <span class="n">custom_profiles</span><span class="p">:</span>
        <span class="c1"># KOID_TAXONID_TAXON-NAME(-nr)</span>
        <span class="n">reviewed</span> <span class="o">=</span> <span class="s1">&#39;False&#39;</span> <span class="k">if</span> <span class="n">profile_name</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s1">&#39;-nr&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;True&#39;</span>
        <span class="n">gene_id</span><span class="p">,</span> <span class="n">taxon_id</span><span class="p">,</span> <span class="n">taxon_name</span> <span class="o">=</span> <span class="n">profile_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gene_id</span> <span class="o">=</span> <span class="n">profile_name</span>
        <span class="n">taxon_id</span> <span class="o">=</span> <span class="n">taxon_name</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="n">annotation</span> <span class="o">=</span> <span class="n">Annotation</span><span class="p">(</span>
        <span class="n">seq_id</span><span class="o">=</span><span class="n">contig</span><span class="p">,</span>
        <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span>
        <span class="n">feat_type</span><span class="o">=</span><span class="n">feat_type</span><span class="p">,</span>
        <span class="n">start</span><span class="o">=</span><span class="n">t_from</span><span class="p">,</span>
        <span class="n">end</span><span class="o">=</span><span class="n">t_to</span><span class="p">,</span>
        <span class="n">score</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>
        <span class="n">strand</span><span class="o">=</span><span class="s1">&#39;-&#39;</span> <span class="k">if</span> <span class="n">frame</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">else</span> <span class="s1">&#39;+&#39;</span><span class="p">,</span>
        <span class="n">phase</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">frame</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="n">db</span><span class="o">=</span><span class="n">db</span><span class="p">,</span>
        <span class="n">gene_id</span><span class="o">=</span><span class="n">gene_id</span><span class="p">,</span>
        <span class="n">taxon_id</span><span class="o">=</span><span class="n">taxon_id</span><span class="p">,</span>
        <span class="n">bitscore</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">7</span><span class="p">]),</span>

        <span class="c1"># custom for HMMER profiles</span>
        <span class="n">aa_from</span><span class="o">=</span><span class="n">aa_from</span><span class="p">,</span>
        <span class="n">aa_to</span><span class="o">=</span><span class="n">aa_to</span><span class="p">,</span>
        <span class="c1"># stores the aa sequence</span>
        <span class="n">aa_seq</span><span class="o">=</span><span class="n">aa_seqs</span><span class="p">[</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">aa_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">aa_to</span><span class="p">],</span>
        <span class="c1"># evalue</span>
        <span class="n">evalue</span><span class="o">=</span><span class="n">score</span><span class="p">,</span>

        <span class="c1"># maintains HMMER profile information:</span>
        <span class="c1"># profile name</span>
        <span class="n">name</span><span class="o">=</span><span class="n">profile_name</span><span class="p">,</span>
        <span class="c1"># both strand/phase (e.g r2)</span>
        <span class="n">frame</span><span class="o">=</span><span class="n">frame</span><span class="p">,</span>
        <span class="c1"># old version of uid</span>
        <span class="c1"># ko_idx=ko_idx,</span>
        <span class="c1"># used in other old profiles, where the taxon name was used instead</span>
        <span class="c1"># of a taxon ID</span>
        <span class="n">taxon_name</span><span class="o">=</span><span class="n">taxon_name</span>
    <span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;reviewed&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">reviewed</span>
    <span class="k">except</span> <span class="ne">UnboundLocalError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># removes the None values from non-custom profiles</span>
    <span class="k">if</span> <span class="n">taxon_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">annotation</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;taxon_id&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">taxon_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">annotation</span><span class="o">.</span><span class="n">attr</span><span class="p">[</span><span class="s1">&#39;taxon_name&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">annotation</span></div>


<div class="viewcode-block" id="parse_gff"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.parse_gff">[docs]</a><span class="k">def</span> <span class="nf">parse_gff</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">gff_type</span><span class="o">=</span><span class="n">from_gff</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionchanged:: 0.4.0</span>
<span class="sd">        In some cases ASCII decoding is not enough, so it is parametrised now</span>

<span class="sd">    .. versionchanged:: 0.3.4</span>
<span class="sd">        added decoding from binary for compatibility with Python3</span>

<span class="sd">    .. versionchanged:: 0.2.6</span>
<span class="sd">        added *strict* parameter</span>

<span class="sd">    .. versionchanged:: 0.2.3</span>
<span class="sd">        correctly handling of GFF with comments of appended sequences</span>

<span class="sd">    .. versionchanged:: 0.1.12</span>
<span class="sd">        added *gff_type* parameter</span>

<span class="sd">    Parse a GFF file and returns generator of :class:`GFFKegg` instances</span>

<span class="sd">    Accepts a file handle or a string with the file name</span>

<span class="sd">    Arguments:</span>
<span class="sd">        file_handle (str, file): file name or file handle to read from</span>
<span class="sd">        gff_type (class): class/function used to parse a GFF annotation</span>
<span class="sd">        strict (bool): if True duplicate keys raise an exception</span>
<span class="sd">        encoding (str): encoding of the file, if ascii fails, use utf8</span>

<span class="sd">    Yields:</span>
<span class="sd">        Annotation: an iterator of :class:`Annotation` instances</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">file_handle</span> <span class="o">=</span> <span class="n">mgkit</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span>

    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Loading GFF from file (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">file_handle</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">file_handle</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">UnicodeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">UnicodeError</span><span class="p">(</span><span class="s2">&quot;Impossible to decode line to </span><span class="si">{}</span><span class="s2">: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">encoding</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>
        <span class="c1"># the first is for GFF with comments and the second for</span>
        <span class="c1"># GFF with the fasta file attached</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">):</span>
            <span class="k">break</span>

        <span class="n">annotation</span> <span class="o">=</span> <span class="n">gff_type</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">annotation</span>

    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;Read </span><span class="si">%d</span><span class="s2"> line from file (</span><span class="si">%s</span><span class="s2">)&quot;</span><span class="p">,</span>
        <span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="nb">getattr</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="s1">&#39;name&#39;</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">file_handle</span><span class="p">))</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="diff_gff"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.diff_gff">[docs]</a><span class="k">def</span> <span class="nf">diff_gff</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">key_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    Returns a simple diff made between a list of gff files. The annotations are</span>
<span class="sd">    grouped using *key_func*, so it depends on it to find similar annotations.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        files (iterable): an iterable of file handles, pointing to GFF files</span>
<span class="sd">        key_func (func): function used to group annotations, defaults to this</span>
<span class="sd">            key: *(x.seq_id, x.strand, x.start, x.end, x.gene_id, x.bitscore)*</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: the returned dictionary keys are determined by key_func and as</span>
<span class="sd">        values lists. The lists elements are tuple whose first element is the</span>
<span class="sd">        index of the file, relative to *files* and the second element is the</span>
<span class="sd">        line number in which the annotation is. Can be used with the</span>
<span class="sd">        :mod:`linecache` module.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">key_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">key_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strand</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">end</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">gene_id</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">bitscore</span><span class="p">)</span>

    <span class="n">gff_diff</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">file_handle</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">files</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">lineno</span><span class="p">,</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">parse_gff</span><span class="p">(</span><span class="n">file_handle</span><span class="p">)):</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">key_func</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">gff_diff</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">index</span><span class="p">,</span> <span class="n">lineno</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">gff_diff</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[(</span><span class="n">index</span><span class="p">,</span> <span class="n">lineno</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">gff_diff</span></div>


<div class="viewcode-block" id="annotation_elongation"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.annotation_elongation">[docs]</a><span class="k">def</span> <span class="nf">annotation_elongation</span><span class="p">(</span><span class="n">ann1</span><span class="p">,</span> <span class="n">annotations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    Given an :class:`Annotation` instance and a list of the instances of the</span>
<span class="sd">    same class, returns the longest overlapping range that can be found and the</span>
<span class="sd">    annotations that are included in it.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        annotations are not checked for seq_id and strand</span>

<span class="sd">    Arguments:</span>
<span class="sd">        ann1 (Annotation): annotation to elongate</span>
<span class="sd">        annotations (iterable): iterable of :class:`Annotation` instances</span>

<span class="sd">    Returns:</span>
<span class="sd">        tuple: the first element is the longest range found, while the the</span>
<span class="sd">        second element is a set with the annotations used</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">used</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">ann1</span><span class="p">])</span>

    <span class="n">union</span> <span class="o">=</span> <span class="p">(</span><span class="n">ann1</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ann1</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">ann2</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">new_union</span> <span class="o">=</span> <span class="n">union_range</span><span class="p">(</span><span class="n">union</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">union</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ann2</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ann2</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">new_union</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">used</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ann2</span><span class="p">)</span>
            <span class="n">union</span> <span class="o">=</span> <span class="n">new_union</span>

    <span class="k">return</span> <span class="n">union</span><span class="p">,</span> <span class="n">used</span></div>


<div class="viewcode-block" id="elongate_annotations"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.elongate_annotations">[docs]</a><span class="k">def</span> <span class="nf">elongate_annotations</span><span class="p">(</span><span class="n">annotations</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    Given an iterable of :class:`Annotation` instances, tries to find the all</span>
<span class="sd">    possible longest ranges and returns them.</span>

<span class="sd">    .. warning::</span>

<span class="sd">        annotations are not checked for seq_id and strand</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): iterable of :class:`Annotation` instances</span>

<span class="sd">    Returns:</span>
<span class="sd">        set: set with the all ranges found</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">annotations</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>

    <span class="n">ranges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ann1</span> <span class="o">=</span> <span class="n">annotations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">union</span><span class="p">,</span> <span class="n">used</span> <span class="o">=</span> <span class="n">annotation_elongation</span><span class="p">(</span><span class="n">ann1</span><span class="p">,</span> <span class="n">annotations</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">union</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ranges</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">ann1</span><span class="o">.</span><span class="n">start</span><span class="p">,</span> <span class="n">ann1</span><span class="o">.</span><span class="n">end</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">annotations</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">annotations</span><span class="p">)</span> <span class="o">-</span> <span class="n">used</span><span class="p">,</span>
                                 <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
            <span class="n">ranges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">union</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ranges</span></div>


<div class="viewcode-block" id="annotation_coverage"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.annotation_coverage">[docs]</a><span class="k">def</span> <span class="nf">annotation_coverage</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">seqs</span><span class="p">,</span> <span class="n">strand</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    Given a list of annotations and a dictionary where the keys are the</span>
<span class="sd">    sequence names referred in the annotations and the values are the sequences</span>
<span class="sd">    themselves, returns a number which indicated how much the sequence length</span>
<span class="sd">    is &quot;covered&quot; in annotations. If *strand* is True the coverage is strand</span>
<span class="sd">    specific.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): iterable of :class:`Annotation` instances</span>
<span class="sd">        seqs (dict): dictionary in which the keys are the sequence names and</span>
<span class="sd">            the values are the sequences</span>
<span class="sd">        strand (bool): if True, the values are strand specific (the</span>
<span class="sd">            annotations) are grouped by (seq_id, strand) instead of seq_id</span>

<span class="sd">    Yields:</span>
<span class="sd">        tuple: the first element is the key, (seq_id, strand) if *strand* is</span>
<span class="sd">        True or seq_id if *strand* is False, and the coverage is the second</span>
<span class="sd">        value.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">strand</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">key_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strand</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">key_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">seq_id</span>

    <span class="n">annotations</span> <span class="o">=</span> <span class="n">group_annotations</span><span class="p">(</span>
        <span class="n">annotations</span><span class="p">,</span>
        <span class="n">key_func</span><span class="o">=</span><span class="n">key_func</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">key_ann</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">annotations</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">seq_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seq_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>

        <span class="n">covered</span> <span class="o">=</span> <span class="n">ranges_length</span><span class="p">(</span><span class="n">elongate_annotations</span><span class="p">(</span><span class="n">key_ann</span><span class="p">))</span>

        <span class="k">yield</span> <span class="n">key</span><span class="p">,</span> <span class="n">covered</span> <span class="o">/</span> <span class="n">seq_len</span> <span class="o">*</span> <span class="mi">100</span></div>


<div class="viewcode-block" id="annotation_coverage_sorted"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.annotation_coverage_sorted">[docs]</a><span class="k">def</span> <span class="nf">annotation_coverage_sorted</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">seqs</span><span class="p">,</span> <span class="n">strand</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.3.1</span>

<span class="sd">    Given a list of annotations and a dictionary where the keys are the</span>
<span class="sd">    sequence names referred in the annotations and the values are the sequences</span>
<span class="sd">    themselves, returns a number which indicated how much the sequence length</span>
<span class="sd">    is &quot;covered&quot; in annotations. If *strand* is True the coverage is strand</span>
<span class="sd">    specific.</span>

<span class="sd">    .. note::</span>

<span class="sd">        It differs from :func:`annotation_coverage` because it assumes the</span>
<span class="sd">        annotations are correctly sorted and in the values yielded</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): iterable of :class:`Annotation` instances</span>
<span class="sd">        seqs (dict): dictionary in which the keys are the sequence names and</span>
<span class="sd">            the values are the sequences</span>
<span class="sd">        strand (bool): if True, the values are strand specific (the</span>
<span class="sd">            annotations) are grouped by (seq_id, strand) instead of seq_id</span>

<span class="sd">    Yields:</span>
<span class="sd">        tuple: the first element is the seq_id, the second the strand (if</span>
<span class="sd">        strand is True, else it&#39;s set to *None*), and the third element is the</span>
<span class="sd">        coverage.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">strand</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">key_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strand</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">key_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="n">x</span><span class="o">.</span><span class="n">seq_id</span>

    <span class="n">annotations</span> <span class="o">=</span> <span class="n">group_annotations_sorted</span><span class="p">(</span>
        <span class="n">annotations</span><span class="p">,</span>
        <span class="n">key_func</span><span class="o">=</span><span class="n">key_func</span>
    <span class="p">)</span>

    <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">seq_id</span> <span class="o">=</span> <span class="n">ann</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">seq_id</span>
        <span class="k">if</span> <span class="n">strand</span><span class="p">:</span>
            <span class="n">ann_strand</span> <span class="o">=</span> <span class="n">ann</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strand</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ann_strand</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">seq_len</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">seq_id</span><span class="p">])</span>

        <span class="n">covered</span> <span class="o">=</span> <span class="n">ranges_length</span><span class="p">(</span><span class="n">elongate_annotations</span><span class="p">(</span><span class="n">ann</span><span class="p">))</span>

        <span class="k">yield</span> <span class="n">seq_id</span><span class="p">,</span> <span class="n">ann_strand</span><span class="p">,</span> <span class="n">covered</span> <span class="o">/</span> <span class="n">seq_len</span> <span class="o">*</span> <span class="mi">100</span></div>


<div class="viewcode-block" id="group_annotations"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.group_annotations">[docs]</a><span class="k">def</span> <span class="nf">group_annotations</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">key_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strand</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.12</span>

<span class="sd">    Group :class:`Annotation` instances in a dictionary by using a key function</span>
<span class="sd">    that returns the key to be used in the dictionary.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): iterable with :class:`Annotation` instances</span>
<span class="sd">        key_func (func): function used to extract the key used in the</span>
<span class="sd">            dictionary, defaults to a function that returns</span>
<span class="sd">            (ann.seq_id, ann.strand)</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: dictionary whose keys are returned by *key_func* and the values</span>
<span class="sd">        are lists of annotations</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; ann = [Annotation(seq_id=&#39;seq1&#39;, strand=&#39;+&#39;, start=10, end=15),</span>
<span class="sd">        ... Annotation(seq_id=&#39;seq1&#39;, strand=&#39;+&#39;, start=1, end=5),</span>
<span class="sd">        ... Annotation(seq_id=&#39;seq1&#39;, strand=&#39;-&#39;, start=30, end=100)]</span>
<span class="sd">        &gt;&gt;&gt; group_annotations(ann)</span>
<span class="sd">        {(&#39;seq1&#39;, &#39;+&#39;): [seq1(+):10-15, seq1(+):1-5], (&#39;seq1&#39;, &#39;-&#39;): [seq1(-):30-100]}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">grouped</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">key_func</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">grouped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">grouped</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotation</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">grouped</span></div>


<div class="viewcode-block" id="group_annotations_sorted"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.group_annotations_sorted">[docs]</a><span class="k">def</span> <span class="nf">group_annotations_sorted</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span>
                             <span class="n">key_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">strand</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.13</span>

<span class="sd">    Group :class:`Annotation` instances by using a key function that returns a</span>
<span class="sd">    key. Assumes that the annotations are already sorted to return an iterator</span>
<span class="sd">    and save memory. One way to sort them is using: `sort -s -k 1,1 -k 7,7` on</span>
<span class="sd">    the file.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): iterable with :class:`Annotation` instances</span>
<span class="sd">        key_func (func): function used to extract the key used in the</span>
<span class="sd">            dictionary, defaults to a function that returns</span>
<span class="sd">            (ann.seq_id, ann.strand)</span>

<span class="sd">    Yields:</span>
<span class="sd">        list: a list of the grouped annotations by *key_func* values</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">curr_key</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
    <span class="n">curr_ann</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">new_key</span> <span class="o">=</span> <span class="n">key_func</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">curr_key</span> <span class="o">==</span> <span class="n">new_key</span><span class="p">:</span>
            <span class="n">curr_ann</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">curr_key</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">curr_ann</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
                <span class="n">curr_key</span> <span class="o">=</span> <span class="n">new_key</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">curr_ann</span>
                <span class="n">curr_key</span> <span class="o">=</span> <span class="n">new_key</span>
                <span class="n">curr_ann</span> <span class="o">=</span> <span class="p">[</span><span class="n">annotation</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">curr_ann</span></div>


<div class="viewcode-block" id="extract_nuc_seqs"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.extract_nuc_seqs">[docs]</a><span class="k">def</span> <span class="nf">extract_nuc_seqs</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">seqs</span><span class="p">,</span> <span class="n">name_func</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">uid</span><span class="p">,</span>
                     <span class="n">reverse</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.13</span>

<span class="sd">    Extract the nucleotidic sequences from a list of annotations. Internally</span>
<span class="sd">    uses the method :meth:`Annotation.get_nuc_seq`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): iterable of :class:`Annotation` instances</span>
<span class="sd">        seqs (dict): dictionary with the sequences referenced in the</span>
<span class="sd">            annotations</span>
<span class="sd">        name_func (func): function used to extract the sequence name to be</span>
<span class="sd">            used, defaults to the uid of the annotation</span>
<span class="sd">        reverse (bool): if True the annotations on the *-* strand are reverse</span>
<span class="sd">            complemented</span>

<span class="sd">    Yields:</span>
<span class="sd">        tuple: tuple whose first element is the sequence name and the second is</span>
<span class="sd">        the sequence to which the annotation refers.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">name_func</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">get_nuc_seq</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">annotation</span><span class="o">.</span><span class="n">seq_id</span><span class="p">],</span> <span class="n">reverse</span><span class="o">=</span><span class="n">reverse</span><span class="p">)</span>

        <span class="k">yield</span> <span class="n">name</span><span class="p">,</span> <span class="n">seq</span></div>


<div class="viewcode-block" id="group_annotations_by_ancestor"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.group_annotations_by_ancestor">[docs]</a><span class="k">def</span> <span class="nf">group_annotations_by_ancestor</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">ancestors</span><span class="p">,</span> <span class="n">taxonomy</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.13</span>

<span class="sd">    Group annotations by the ancestors provided.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): annotations to group</span>
<span class="sd">        ancestors (iterable): list of ancestors accepted</span>
<span class="sd">        taxonomy: taxonomy class</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: grouped annotations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ann_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">((</span><span class="n">ancestor</span><span class="p">,</span> <span class="p">[])</span> <span class="k">for</span> <span class="n">ancestor</span> <span class="ow">in</span> <span class="n">ancestors</span><span class="p">)</span>

    <span class="n">unknown</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">anc_found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">ancestor</span><span class="p">,</span> <span class="n">anc_ids</span> <span class="ow">in</span> <span class="n">viewitems</span><span class="p">(</span><span class="n">ancestors</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">taxonomy</span><span class="o">.</span><span class="n">is_ancestor</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">taxon_id</span><span class="p">,</span> <span class="n">anc_ids</span><span class="p">):</span>
                <span class="n">ann_dict</span><span class="p">[</span><span class="n">ancestor</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
                <span class="n">anc_found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">anc_found</span><span class="p">:</span>
            <span class="n">unknown</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ann_dict</span><span class="p">,</span> <span class="n">unknown</span></div>


<div class="viewcode-block" id="split_gff_file"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.split_gff_file">[docs]</a><span class="k">def</span> <span class="nf">split_gff_file</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">name_mask</span><span class="p">,</span> <span class="n">num_files</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.14</span>

<span class="sd">    .. versionchanged:: 0.2.6</span>
<span class="sd">        now accept a file object as sole input</span>

<span class="sd">    .. versionchanged:: 0.4.0</span>
<span class="sd">        added *encoding* parameter</span>

<span class="sd">    Splits a GFF, or a list of them, into a number of files. It is assured that</span>
<span class="sd">    annotations for the same sequence are kept in the same file, which is</span>
<span class="sd">    useful for cases like filtering, even when the annotations are from</span>
<span class="sd">    different GFF files.</span>

<span class="sd">    Internally, a structure is kept to check if a sequence ID is already been</span>
<span class="sd">    stored to a file, in which case the annotation is written to that file,</span>
<span class="sd">    otherwise a random file handles (among the open ones) is chosen.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        file_handle (str, list): a single or list of file handles (or file</span>
<span class="sd">           names), from which the GFF annotations are read</span>
<span class="sd">        name_mask (str): a string used as template for the output file names</span>
<span class="sd">            on which the function applies :func:`string.format`</span>
<span class="sd">        num_files (int): the number of files to split the records</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; import glob</span>
<span class="sd">        &gt;&gt;&gt; files = glob.glob(&#39;*.gff&#39;)</span>
<span class="sd">        &gt;&gt;&gt; name_mask = &#39;split-file-{0}.gff&#39;</span>
<span class="sd">        &gt;&gt;&gt; split_gff_file(files, name_mask, 5)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="n">IOBase</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file_handle</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">file_handle</span> <span class="o">=</span> <span class="p">[</span><span class="n">file_handle</span><span class="p">]</span>

        <span class="n">file_handle</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span>
            <span class="o">*</span><span class="p">(</span><span class="n">mgkit</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s1">&#39;rb&#39;</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">file_handle</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">out_handles</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">mgkit</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">name_mask</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filen</span><span class="p">),</span> <span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">filen</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_files</span><span class="p">)</span>
    <span class="p">]</span>

    <span class="n">seq_ids</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file_handle</span><span class="p">:</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="n">encoding</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;#&#39;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">):</span>
            <span class="k">break</span>

        <span class="n">seq_id</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">out_handle</span> <span class="o">=</span> <span class="n">out_handles</span><span class="p">[</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">seq_id</span><span class="p">]]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">new_index</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">num_files</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">seq_ids</span><span class="p">[</span><span class="n">seq_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_index</span>
            <span class="n">out_handle</span> <span class="o">=</span> <span class="n">out_handles</span><span class="p">[</span><span class="n">new_index</span><span class="p">]</span>

        <span class="n">out_handle</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;ascii&#39;</span><span class="p">))</span></div>


<div class="viewcode-block" id="load_gff_base_info"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.load_gff_base_info">[docs]</a><span class="k">def</span> <span class="nf">load_gff_base_info</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">taxonomy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">include_taxa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is useful if the number of annotations in a GFF is high or</span>
<span class="sd">    there are memory constraints on the system. It returns a dictionary that</span>
<span class="sd">    can be used with functions like</span>
<span class="sd">    :func:`mgkit.counts.func.load_sample_counts`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        files (iterable, str): file name or list of paths of GFF files</span>
<span class="sd">        taxonomy: taxonomy pickle file, needed if include_taxa is not None</span>
<span class="sd">        exclude_ids (set, list): a list of gene_id to exclude from the</span>
<span class="sd">            dictionary</span>
<span class="sd">        include_taxa (int, iterable): a taxon_id or list thereof to be passed</span>
<span class="sd">            to :meth:`mgkit.taxon.taxonomy.is_ancestor`, so only the taxa that</span>
<span class="sd">            have the those taxon_id(s) as ancestor(s) are kept</span>
<span class="sd">        encoding (str): passed to :func:`parse_gff`</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: dictionary where the key is :attr:`Annotation.uid` and the value</span>
<span class="sd">        is a tuple (:attr:`Annotation.gene_id`, :attr:`Annotation.taxon_id`)</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">files</span><span class="p">]</span>

    <span class="n">infos</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">parse_gff</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">):</span>
            <span class="c1"># no information on taxa - exclude</span>
            <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="n">taxon_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># to exclude ribosomial genes or any other kind</span>
            <span class="k">if</span> <span class="n">exclude_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="n">gene_id</span> <span class="ow">in</span> <span class="n">exclude_ids</span><span class="p">:</span>
                    <span class="k">continue</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">include_taxa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">taxonomy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">taxonomy</span><span class="o">.</span><span class="n">is_ancestor</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">taxon_id</span><span class="p">,</span> <span class="n">include_taxa</span><span class="p">):</span>
                    <span class="k">continue</span>

            <span class="n">infos</span><span class="p">[</span><span class="n">annotation</span><span class="o">.</span><span class="n">uid</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">gene_id</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">taxon_id</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">infos</span></div>


<div class="viewcode-block" id="load_gff_mappings"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.load_gff_mappings">[docs]</a><span class="k">def</span> <span class="nf">load_gff_mappings</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">map_db</span><span class="p">,</span> <span class="n">taxonomy</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">exclude_ids</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">include_taxa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s1">&#39;ascii&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function is useful if the number of annotations in a GFF is high or</span>
<span class="sd">    there are memory constraints on the system. It returns a dictionary that</span>
<span class="sd">    can be used with functions like</span>
<span class="sd">    :func:`mgkit.counts.func.load_sample_counts`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        files (iterable, str): file name or list of paths of GFF files</span>
<span class="sd">        map_db (str): any kind mapping in the GFF, as passed to</span>
<span class="sd">            :meth:`Annotation.get_mapping`</span>
<span class="sd">        taxonomy: taxonomy pickle file, needed if include_taxa is not None</span>
<span class="sd">        exclude_ids (set, list): a list of gene_id to exclude from the</span>
<span class="sd">            dictionary</span>
<span class="sd">        include_taxa (int, iterable): a taxon_id or list thereof to be passed</span>
<span class="sd">            to :meth:`mgkit.taxon.taxonomy.is_ancestor`, so only the taxa that</span>
<span class="sd">            have the those taxon_id(s) as ancestor(s) are kept</span>
<span class="sd">        encoding (str): passed to :func:`parse_gff`</span>

<span class="sd">    Returns:</span>
<span class="sd">        dict: dictionary where the key is :attr:`Annotation.gene_id` and the</span>
<span class="sd">        value is a list of mappings, as returned by</span>
<span class="sd">        :meth:`Annotation.get_mapping`</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">infos</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">for</span> <span class="n">fname</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">parse_gff</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="n">encoding</span><span class="p">):</span>
            <span class="c1"># skips genes that are already in the mapping</span>
            <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="n">gene_id</span> <span class="ow">in</span> <span class="n">infos</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># exclude genes with no taxonomic information</span>
            <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="n">taxon_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">exclude_ids</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">annotation</span><span class="o">.</span><span class="n">gene_id</span> <span class="ow">in</span> <span class="n">exclude_ids</span><span class="p">:</span>
                    <span class="k">continue</span>

            <span class="c1"># skips non bacterial/achaeal genes</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">include_taxa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">taxonomy</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">taxonomy</span><span class="o">.</span><span class="n">is_ancestor</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">taxon_id</span><span class="p">,</span> <span class="n">include_taxa</span><span class="p">):</span>
                    <span class="k">continue</span>

            <span class="n">infos</span><span class="p">[</span><span class="n">annotation</span><span class="o">.</span><span class="n">gene_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">annotation</span><span class="o">.</span><span class="n">get_mapping</span><span class="p">(</span><span class="n">map_db</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">infos</span></div>


<div class="viewcode-block" id="parse_gff_files"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.parse_gff_files">[docs]</a><span class="k">def</span> <span class="nf">parse_gff_files</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.15</span>

<span class="sd">    .. versionchanged:: 0.2.6</span>
<span class="sd">        added *strict* parameter</span>

<span class="sd">    Function that returns an iterator of annotations from multiple GFF files.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        files (iterable, str): iterable of file names of GFF files, or a single</span>
<span class="sd">            file name</span>
<span class="sd">        strict (bool): if True duplicate keys raise an exception</span>

<span class="sd">    Yields:</span>
<span class="sd">        :class:`Annotation`: iterator of annotations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">files</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">files</span> <span class="o">=</span> <span class="p">[</span><span class="n">files</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">itertools</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">parse_gff</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="n">strict</span><span class="p">)</span> <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">files</span><span class="p">))</span></div>


<div class="viewcode-block" id="get_annotation_map"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.get_annotation_map">[docs]</a><span class="k">def</span> <span class="nf">get_annotation_map</span><span class="p">(</span><span class="n">annotations</span><span class="p">,</span> <span class="n">key_func</span><span class="p">,</span> <span class="n">value_func</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.15</span>

<span class="sd">    Applies two functions to an iterable of annotations with an iterator</span>
<span class="sd">    returned with the applied functions. Useful to build a dictionary</span>

<span class="sd">    Arguments:</span>
<span class="sd">        annotations (iterable): iterable of annotations</span>
<span class="sd">        key_func (func): function that accept an annotation as argument and</span>
<span class="sd">            returns one value, the first of the returned tuple</span>
<span class="sd">        value_func (func): function that accept an annotation as argument and</span>
<span class="sd">            returns one value, the second of the returned tuple</span>

<span class="sd">    Yields:</span>
<span class="sd">        tuple: a tuple where the first value is the result of *key_func* on</span>
<span class="sd">        the passed annotation and the second is the value returned by</span>
<span class="sd">        *value_func* on the same annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">key_func</span><span class="p">(</span><span class="n">annotation</span><span class="p">),</span> <span class="n">value_func</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span></div>


<div class="viewcode-block" id="convert_gff_to_gtf"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.convert_gff_to_gtf">[docs]</a><span class="k">def</span> <span class="nf">convert_gff_to_gtf</span><span class="p">(</span><span class="n">file_in</span><span class="p">,</span> <span class="n">file_out</span><span class="p">,</span> <span class="n">gene_id_attr</span><span class="o">=</span><span class="s1">&#39;uid&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.1.16</span>

<span class="sd">    Function that uses :meth:`Annotation.to_gtf` to convert a GFF into GTF.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        file_in (str, file): either file name or file handle of a GFF file</span>
<span class="sd">        file_out (str): file name to which write the converted annotations</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">LOG</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing GTF file to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">file_out</span><span class="p">)</span>
    <span class="n">file_out</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="n">file_out</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">parse_gff</span><span class="p">(</span><span class="n">file_in</span><span class="p">):</span>
        <span class="n">file_out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">to_gtf</span><span class="p">())</span></div>


<div class="viewcode-block" id="from_mongodb"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_mongodb">[docs]</a><span class="k">def</span> <span class="nf">from_mongodb</span><span class="p">(</span><span class="n">record</span><span class="p">,</span> <span class="n">lineage</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    .. versionadded:: 0.2.1</span>

<span class="sd">    .. versionchanged:: 0.2.2</span>
<span class="sd">        added handling of *counts_* and *fpkms_*</span>

<span class="sd">    .. versionchanged:: 0.2.6</span>
<span class="sd">        better handling of missing attributes and added *lineage* parameter</span>

<span class="sd">    Returns a :class:`Annotation` instance from a MongoDB record (created)</span>
<span class="sd">    using :meth:`Annotation.to_mongodb`. The actual record returned by pymongo</span>
<span class="sd">    is a dictionary that is copied, manipulated and passed to the</span>
<span class="sd">    :meth:`Annotation.__init__`.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        record (dict): a dictionary with the full record from a MongoDB query</span>
<span class="sd">        lineage (bool): indicates if the lineage information in the record</span>
<span class="sd">            should be kept in the annotation</span>

<span class="sd">    Returns:</span>
<span class="sd">        Annotation: instance of :class:`Annotation` object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">record</span> <span class="o">=</span> <span class="n">record</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="n">record</span><span class="p">[</span><span class="s1">&#39;uid&#39;</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">record</span><span class="p">[</span><span class="s1">&#39;_id&#39;</span><span class="p">]</span>

    <span class="k">if</span> <span class="s1">&#39;map&#39;</span> <span class="ow">in</span> <span class="n">record</span><span class="p">:</span>

        <span class="n">mappings</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">record</span><span class="p">[</span><span class="s1">&#39;map&#39;</span><span class="p">]</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">record</span><span class="p">[</span><span class="s1">&#39;EC&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mappings</span><span class="p">[</span><span class="s1">&#39;ec&#39;</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">mappings</span><span class="p">[</span><span class="s1">&#39;ec&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">mappings</span><span class="p">:</span>
                <span class="n">record</span><span class="p">[</span><span class="s1">&#39;map_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">upper</span><span class="p">())]</span> <span class="o">=</span> <span class="s1">&#39;,&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">mappings</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">counts</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="s1">&#39;counts&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">del</span> <span class="n">record</span><span class="p">[</span><span class="s1">&#39;counts&#39;</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">counts</span><span class="p">:</span>
                <span class="n">record</span><span class="p">[</span><span class="s1">&#39;counts_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">counts</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">fpkms</span> <span class="o">=</span> <span class="n">record</span><span class="p">[</span><span class="s1">&#39;fpkms&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">record</span><span class="p">[</span><span class="s1">&#39;fpkms&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">fpkms</span><span class="p">:</span>
            <span class="n">record</span><span class="p">[</span><span class="s1">&#39;fpkms_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="o">=</span> <span class="n">fpkms</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">if</span> <span class="p">(</span><span class="s1">&#39;lineage&#39;</span> <span class="ow">in</span> <span class="n">record</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">lineage</span><span class="p">):</span>
        <span class="k">del</span> <span class="n">record</span><span class="p">[</span><span class="s1">&#39;lineage&#39;</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">Annotation</span><span class="p">(</span><span class="o">**</span><span class="n">record</span><span class="p">)</span></div>


<div class="viewcode-block" id="from_prodigal_frag"><a class="viewcode-back" href="../../../api/mgkit.io.gff.html#mgkit.io.gff.from_prodigal_frag">[docs]</a><span class="k">def</span> <span class="nf">from_prodigal_frag</span><span class="p">(</span><span class="n">main_gff</span><span class="p">,</span> <span class="n">blast_gff</span><span class="p">,</span> <span class="n">attr</span><span class="o">=</span><span class="s1">&#39;ID&#39;</span><span class="p">,</span> <span class="n">split_func</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    .. versionchanged:: 0.3.3</span>
<span class="sd">        fixed a bug for the strand, also the code is tested</span>

<span class="sd">    .. versionadded:: 0.2.6</span>
<span class="sd">        *experimental*</span>

<span class="sd">    Reads the GFF given in output by PRODIGAL and the resulting GFF from using</span>
<span class="sd">    BLAST (or other software) on the aa or nucleotide file output by PRODIGAL.</span>

<span class="sd">    It then integrates the two outputs, so to the PRODIGAL GFF is added the</span>
<span class="sd">    information from the the output of the gene prediction software used.</span>

<span class="sd">    Arguments:</span>
<span class="sd">        main_gff (file): GFF file from PRODIGAL</span>
<span class="sd">        blast_gff (file): GFF with the returned annotations</span>
<span class="sd">        attr (str): attribute in the PRODIGAL GFF that is used to identify an</span>
<span class="sd">            annotation</span>
<span class="sd">        split_func (func): function to rename the headers from the predicted</span>
<span class="sd">            sequences back to their parent sequence</span>

<span class="sd">    Yields:</span>
<span class="sd">        annotation: annotation for each *blast_gff* back translated</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">split_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">def</span> <span class="nf">split_func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">rsplit</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="n">prodigal_gff</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">parse_gff</span><span class="p">(</span><span class="n">main_gff</span><span class="p">,</span> <span class="n">strict</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">annotation</span><span class="o">.</span><span class="n">seq_id</span><span class="p">,</span>
            <span class="n">split_func</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">))[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">prodigal_gff</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">annotation</span><span class="o">.</span><span class="n">start</span><span class="p">,</span>
            <span class="n">annotation</span><span class="o">.</span><span class="n">end</span><span class="p">,</span>
            <span class="n">annotation</span><span class="o">.</span><span class="n">strand</span><span class="p">,</span>
            <span class="n">annotation</span><span class="o">.</span><span class="n">get_attr</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">parse_gff</span><span class="p">(</span><span class="n">blast_gff</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">split_func</span><span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">seq_id</span><span class="p">)</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;prodigal_start&#39;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">start</span><span class="p">)</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;prodigal_end&#39;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">end</span><span class="p">)</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;prodigal_strand&#39;</span><span class="p">,</span> <span class="n">annotation</span><span class="o">.</span><span class="n">strand</span><span class="p">)</span>

        <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">p_id</span> <span class="o">=</span> <span class="n">prodigal_gff</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="n">annotation</span><span class="o">.</span><span class="n">seq_id</span> <span class="o">=</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">end</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">strand</span> <span class="o">=</span> <span class="n">strand</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">set_attr</span><span class="p">(</span><span class="s1">&#39;prodigal_ID&#39;</span><span class="p">,</span> <span class="n">p_id</span><span class="p">)</span>
        <span class="k">yield</span> <span class="n">annotation</span></div>
</pre></div>

           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        
        &copy; Copyright 2013-2020, Francesco Rubino

    </p>
  </div>
    
    
    
    Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>